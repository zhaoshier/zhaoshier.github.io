(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{604:function(t,o,r){"use strict";r.r(o);var s=r(3),_=Object(s.a)({},(function(){var t=this,o=t.$createElement,r=t._self._c||o;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("p",[r("a",{attrs:{href:"https://blog.csdn.net/cc18868876837/article/details/81211729?utm_medium=distribute.pc_relevant.none-task-blog-title-2&spm=1001.2101.3001.4242",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考文档"),r("OutboundLink")],1)]),t._v(" "),r("h3",{attrs:{id:"_1-举例"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-举例"}},[t._v("#")]),t._v(" 1.举例")]),t._v(" "),r("p",[r("strong",[t._v("创建一个构造函数Foo(),并用new关键字实例化该构造函数得到一个实例化对象f1。")])]),t._v(" "),r("div",{staticClass:"language-js line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-js"}},[r("code",[r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("Foo")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" f1 "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Foo")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br"),r("span",{staticClass:"line-number"},[t._v("2")]),r("br")])]),r("p",[r("strong",[t._v("new操作符将函数作为构造器进行调用时的过程")]),t._v("："),r("font",{attrs:{color:"#3eaf7c"}},[t._v("函数被调用，然后新创建一个对象，并且成了函数的上下文（也就是此时函数内部的this是指向该新创建的对象，这意味着我们可以在构造器函数内部通过this参数初始化值），最后返回该新对象的引用。")])],1),t._v(" "),r("p",[r("img",{attrs:{src:"https://gitee.com/zhaoshier/blogimage/raw/master/images/20202022Prototype1.png",alt:"1"}})]),t._v(" "),r("h3",{attrs:{id:"_2-proto-属性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-proto-属性"}},[t._v("#")]),t._v(" 2. __proto__属性")]),t._v(" "),r("p",[r("strong",[t._v("记住")]),t._v("：①__proto__和constructor属性是"),r("strong",[t._v("对象")]),t._v("所独有的；② prototype属性是"),r("strong",[t._v("函数")]),t._v("所独有的。\nJS中的函数也是一种对象，因此函数拥有__proto__、constructor、prototype三种属性。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://gitee.com/zhaoshier/blogimage/raw/master/images/20202022Prototype2.jpg",alt:"2"}})]),t._v(" "),r("p",[t._v("图：__proto__属性都是由一个对象指向一个对象，即指向它们的原型对象（也可以理解为父对象），那么这个属性的作用是什么呢？它的作用就是"),r("font",{attrs:{color:"#3eaf7c"}},[t._v("当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（可以理解为父对象）里找，如果父对象也不存在这个属性，则继续往父对象的__proto__属性所指向的那个对象（可以理解为爷爷对象）里找，如果还没找到，则继续往上找…直到原型链顶端null（可以理解为原始人。。。），再往上找就相当于在null上取值，会报错")]),t._v("（可以理解为，再往上就已经不是“人”的范畴了，找不到了，到此结束，null为原型链的终点），由以上这种通过__proto__属性来连接对象直到null的一条链即为我们所谓的原型链。")],1),t._v(" "),r("h3",{attrs:{id:"_3-prototype属性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-prototype属性"}},[t._v("#")]),t._v(" 3. prototype属性")]),t._v(" "),r("p",[t._v("prototype属性是"),r("strong",[t._v("函数")]),t._v("所独有的。它是从"),r("strong",[t._v("一个函数指向一个对象")]),t._v("。\n它的含义是"),r("strong",[t._v("函数的原型对象")]),t._v("，也就是这个函数（其实所有函数都可以作为构造函数）所创建的实例的原型对象，由此可知：f1."),r("strong",[t._v("proto")]),t._v(" === Foo.prototype，它们两个完全一样。\n"),r("strong",[t._v("prototype属性的作用")]),t._v("："),r("font",{attrs:{color:"#3eaf7c"}},[t._v("让该函数所实例化的对象们都可以找到公用的属性和方法。任何函数在创建的时候，其实会默认同时创建该函数的prototype对象。")])],1),t._v(" "),r("p",[r("img",{attrs:{src:"https://gitee.com/zhaoshier/blogimage/raw/master/images/20202022Prototype3.png",alt:"3"}})]),t._v(" "),r("h3",{attrs:{id:"_4-constructor属性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-constructor属性"}},[t._v("#")]),t._v(" 4. constructor属性")]),t._v(" "),r("p",[t._v("对象独有的，它是从"),r("strong",[t._v("一个对象指向一个函数")]),t._v("，含义就是指向"),r("strong",[t._v("该对象的构造函数")]),t._v("。\n从图中可以看出："),r("strong",[t._v("Function这个对象比较特殊，它的构造函数就是它自己")]),t._v("（因为Function可以看成是一个函数，也可以是一个对象），所有函数和对象最终都是由Function构造函数得来，所以constructor属性的终点就是Function这个函数。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://gitee.com/zhaoshier/blogimage/raw/master/images/20202022Prototype4.png",alt:"4"}})]),t._v(" "),r("p",[r("strong",[t._v("每个对象都有构造函数")]),t._v("，即每个对象都可找到对应的constructor，创建对象的前提是需要有constructor，constructor可以是对象自己本身显式定义的或者通过__proto__在原型链中找到的。\n"),r("strong",[t._v("单从constructor这个属性来讲，只有prototype对象才有")]),t._v("。函数在创建的时候，JS会同时创建一个该函数对应的prototype对象，而"),r("font",{attrs:{color:"#3eaf7c"}},[r("strong",[t._v("函数创建的对象."),r("strong",[t._v("proto")]),t._v(" === 该函数.prototype，该函数.prototype.constructor===该函数本身")])]),t._v("，故通过函数创建的对象即使自己没有constructor属性，它也能通过__proto__找到对应的constructor，所以任何对象最终都可以找到其构造函数（null如果当成对象的话，将null除外）")],1),t._v(" "),r("p",[r("img",{attrs:{src:"https://gitee.com/zhaoshier/blogimage/raw/master/images/20202022Prototype5.png",alt:"5"}})]),t._v(" "),r("h3",{attrs:{id:"_5-总结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-总结"}},[t._v("#")]),t._v(" 5. 总结")]),t._v(" "),r("ul",[r("li",[t._v("牢记两点：①__proto__和constructor属性是对象所独有的；② prototype属性是函数所独有的，因为函数也是一种对象，所以函数也拥有__proto__和constructor属性。")]),t._v(" "),r("li",[t._v("__proto__属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（父对象）里找，一直找，直到__proto__属性的终点null，再往上找就相当于在null上取值，会报错。通过__proto__属性将对象连接起来的这条链路即我们所谓的原型链。")]),t._v(" "),r("li",[r("strong",[t._v("prototype属性的作用")]),t._v("就是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1."),r("strong",[t._v("proto")]),t._v(" === Foo.prototype。")]),t._v(" "),r("li",[t._v("constructor属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。")])])])}),[],!1,null,null,null);o.default=_.exports}}]);